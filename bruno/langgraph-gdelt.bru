meta {
  name: "LangGraph GDELT Dev Server"
  type: "collection"
}

env "local-dev" {
  base_url: "http://127.0.0.1:2024"
  assistant_id: "gdelt"
  thread_id: ""
  run_id: ""
}

# ---------------------------------------------------------
# 1) OPTIONAL: Introspect schemas for the gdelt graph
# ---------------------------------------------------------
request "get-gdelt-schemas" {
  method: "GET"
  url: "{{base_url}}/assistants/{{assistant_id}}/schemas"

  headers {
    Accept: "application/json"
  }
}

# ---------------------------------------------------------
# 2) Create a new thread
# ---------------------------------------------------------
request "create-thread" {
  method: "POST"
  url: "{{base_url}}/threads"

  headers {
    Content-Type: "application/json"
    Accept: "application/json"
  }

  body: json({
    // empty body is fine for dev; use metadata here if desired
  })
}

# After running this, copy the returned `thread_id`
# into the environment variable `thread_id`.

# ---------------------------------------------------------
# 3) Run the gdelt graph on that thread (blocking)
# ---------------------------------------------------------
request "run-gdelt-wait" {
  method: "POST"
  url: "{{base_url}}/threads/{{thread_id}}/runs/wait"

  headers {
    Content-Type: "application/json"
    Accept: "application/json"
  }

  body: json({
    assistant_id: "{{assistant_id}}",
    input: {
      // Match this to your State TypedDict â€“ e.g. "query" or "question"
      query: "how was llamaindex used in the paper?"
    }
  })
}

# This returns:
# - values: final or partial state
# - optionally __interrupt__: [...] if the graph paused for HITL
# You can also grab run_id from the response if needed.

# ---------------------------------------------------------
# 4) Inspect the current thread state
# ---------------------------------------------------------
request "get-thread" {
  method: "GET"
  url: "{{base_url}}/threads/{{thread_id}}"

  headers {
    Accept: "application/json"
  }
}

# ---------------------------------------------------------
# 5) Resume after an interrupt (HITL)
# ---------------------------------------------------------
request "resume-after-interrupt" {
  method: "POST"
  url: "{{base_url}}/threads/{{thread_id}}/runs/wait"

  headers {
    Content-Type: "application/json"
    Accept: "application/json"
  }

  body: json({
    assistant_id: "{{assistant_id}}",
    command: {
      // Provide whatever human input your graph expects here
      resume: "Please continue using this edited text / decision."
    }
  })
}

# ---------------------------------------------------------
# 6) (Optional) Get run details if you store run_id
# ---------------------------------------------------------
request "get-run" {
  method: "GET"
  url: "{{base_url}}/threads/{{thread_id}}/runs/{{run_id}}"

  headers {
    Accept: "application/json"
  }
}